# Off-Path TCP Exploits: Global Rate Limit Considered Dangerous

* [PDF](http://www.cs.ucr.edu/~zhiyunq/pub/sec16_TCP_pure_offpath.pdf)

## Notes (08-16-2016)

### 1. Introduction
* "The root cause of the vulnerability is the introduction
  of the challenge ACK responses [26] and the global
  rate limit imposed on certain TCP control packets. The
  feature is outlined in RFC 5961..."
  * TODO: Review challenge ACK RFC.

### 2. Background
* One key requirement: Attacker must be able to send IP-spoofed packets to the target server and target client.
* Blind in-window attacks: In short, the typical TCP-spoofing attacks. Detailed requirements:
	* Must know the (Source IP, Source Port, Destination IP, Destination Port) tuple.
	* Must send spoofed packet with an acceptable Sequence Number in the context of the spoofed connection. In other words:
		* `Expected Next Byte Sequence Number <= Attacker-Guessed Sequence Number <= Expected Next Byte Sequence Number + Recieve Window Size`
	* Mitigations to blind in-window attacks are discussed in [RFC5961](https://tools.ietf.org/html/rfc5961)

#### 2.1. Mitigating the Blind Reset Attack using the SYN Bit
* Blind in-window attacks can be used to kill a connection by sending a spoofed SYN packet (which causes the connection to reset).
* Prior to RFC5961 the Linux kernel did the following:
	* If spoofed sequence number was outside the window, an ACK would be sent back.
	* Otherwise, the connection would reset.
* RFC5961 suggests the following:
	* If a node receives a SYN packet, always send an ACK back (this is a "challenge ACK"). 
	  This asks the sending node to confirm the close of the connection.
	* If the sending SYN packet was legitimate, the sending node actually wants to kill the
	  connection. The sending node will now send a RST packet with the correct sequence number
	  derived from the challenge ACK packet.

#### 2.2.  Mitigating the Blind Reset Attack using the RST Bit
* Attackers could do the attack in (2.1) by spoofing a RST packet.
* Prior to RFC 5961 the kernel behaved similarly to the SYN behavior from (2.1).
* RFC5961 suggests the following:
	* Does not respond to RST packets with invalid sequence numbers
	* If the sequence number _exactly_ matches expected sequence number the connection is reset.
	* If the sequence number is not exact but within the valid window, a challenge ACK is sent.

#### 2.3 Mitigating the Blind Data Injection
* If an attacker didn't want to kill the connection, they could attempt to spoof valid DATA packets into a victim's connection.
* Prior to RFC5961 the kernel did the following upon receiving a DATA packet:
	* Check the sequence number to make sure its within the window size.
	* Check the ACK number to see if its within the window size.
		* ACK numbers have a huge window size.
		* ACK numbers are valid if they are in the range: 
			* `[Sequence Number of First Unacknowledged Byte - (2^32 - 1) , Seqence Number of Next Byte to be Sent]`
* RFC5961 suggests the following:
	* Same sequence number checks as before.
	* ACK numbers are in a smaller window:
		* `[Sequence Number of the First Unacknowledged Byte - Maximum Window Size the Receiver Has Ever Seen From Its Peer , Sequence Number of Next Byte to be Sent]`
		* The idea here being we don't want sequence numbers that are too old or too new.
	* There is a "challenge ACK window" where ACKs are considered invalid but receive challenge ACKs as a response.

#### ACK Throttling
* To prevent resource exhaustion, one can define a challenge ACK throttling mechanism.
* This will limit the number of challenge ACKs that can be sent in a certain interval.
* The Linux kernel uses a challenge ACK interval. The count of challenge acks is _stored in a global variable shared by all TCP connections._
    * The default value is 100. We'll refer to this maximum as `CHALLENGE_ACK_MAX`.

### 3. Vulnerability Overview
* High-level attack:
	1. Send spoofed packets to the victim connection 
	2. Use a valid attacker-initiated connection to trigger contention in the global ACK challenge counter.
	   Use this connection to max-out the ACK challenge counter.
	3. Count the number of challenge ACKs received.
* If the count of packets from step 3 is _less than the maximum ACK challenge counter_, that means the Kernel must have
  responded to spoofed packets from step 1 with challenge ACKs.
* If this is the case, multiple things can be inferred:
* *We can infer the validity of the spoofed connection tuple:*
	* A challenge ACK will not be sent to the spoofed packet if the spoofed tuple is not an active connection.
	* Therefore, if the attacker receives `CHALLENGE_ACK_MAX` challenge ACKs, there is not an active connection for the spoofed tuple.
	* If the attacker receives `CHALLENGE_ACK_MAX-1` challenge ACKs, there must be an active connection on that tuple.
* *We can infer if a sequence number is within the validity window:*
	* Assume we know a valid TCP connection tuple, the attacker can spoof a RST packet to the target on this connection.
	* If the guessed sequence number of the spoofed RST packet was within the sequence number window (but not exact!) a challenge ACK is sent (see section 2.2)
	* Therefore, if the attacker receives `CHALLENGE_ACK_MAX` challenge ACKs, the guessed sequence number was not in the window.
	* If the attacker receives `CHALLENGE_ACK_MAX-1` challenge ACKs, the guessed sequence number was in the window.
* *We can infer if an ACK number is within the validity window:*
	* Assume we have a valid connection tuple and a in-window sequence number.
	* Just as before, this can be used to infer if the spoofed ACK number is in the challenge ACK window.

### 4. Off-Path Connection Reset Attack
* This section details the practical attack (plus other considerations) of a spoofed connection reset using connection tuple and sequence number inference from section 3.

#### 4.1 Time Synchronization
* Practically, we need all spoofed and non-spoofed packets to be sent within the challenge ACK interval.
* Naive Attempt 1: Send all packets (spoofed and non-spoofed) in a tiny interval (e.g. 10 ms)
	* This causes congestion and packet loss
	* Too many factors play into the actually turnaround time from the victim server
* Naive Attempt 2: Use NTP
	* No guarantees the victim server uses NTP
* Their Solution: Use challenge acks as a side channel (again!)
    	* One can send 200 in-window RST packets spread out evenly over a one-second interval.
	* If more than 100 challenge ACKs were received, the 200 in-window RST packets crossed the ack challenge max interval (i.e. attacker is not synced with the server)
	* Shift the timing of the 200 packets until only 100 RST packets are received. This means all 200 packets were sent in the interval.
	* This 200 probe time synchronization step can be done cleverly in about 3 (200 packet) trials.

#### 4.2 Connection (Four-tuple) Inference
* Practically speaking, the only difficulty in this attack is guessing the ephemeral port number used by one of the targets.
* Naive Attempt 1: Bruteforce the port number.
	* This is inefficient.
* Their solution: Use knowledge of Linux ephemeral port behavior and understand bandwidth to come up with a search algorithm.
    	* If bandwidth is good (i.e. you can send at least half the ephemeral port search space in a 1-second interval), a binary search can be done over the set of possible ports.
	* An optimization of the binary search technique could be dividing the search space into buckets and sending as many buckets as possible out at once.
	* For poor bandwidth connections, the attacker can try as many ports as possible until the search space is small enough to do a binary search.

#### 4.3 Sequence Number Inference
* Unlike ephemeral port guessing, there is some leeway in guessing sequence numbers (i.e. the receive window).
	* This can be leveraged for guessing. The sequence number search space can be reduced by the receive window size by dividing guesses into window-sized "blocks".
	* Now, an attacker can just do a binary search over this "blocked" search space.
	* In practice, this is still a pretty large search space.
	* Additionally, an off-path attacker may not know the window size and cannot properly guess the "block size" of the search space (also window sizes may change).
		* The authors use the initial window size from a valid connection as the (possibly conservative) "block size".
* The sequence number inference process:
	1. Send as many blocks of sequence numbers as possible (the authors call this group of blocks a "chunk")
		* If 100 challenge ACKs are received, move on to the next set of blocks. 
		* If 99 received, we are in range.
		* If less than 99 received, than the assumed window size is probably too small.
	2. Narrow down the "chunk" to a single block.
		* To narrow the chunk down, a binary-search (or multi-bin search) can be done.
		* The bin-search here is detailed further in the paper. The basic idea is each "bin" is uniquely encoded by the number of RST packets sent for the blocks in that bin for that round.
	3. Find the correct sequence number using binary search.
		* Nailing down the sequence number relies on the observation that the server's current expected sequence number is the highest value in the block that will not trigger a challenge ACK.
		* You could also do a bin-search here.

#### 5. Off-Path Connection Hijacking Attack
* The grand finale!	
* This section starts off with some (interesting) challenges that an successful attack must overcome:
	1. Unwanted connection reset
		* The sequence number inference step could kill the connection by supplying a RST packet with the exact expected sequence number.
	2. Identifying both the sequence and the ACK numbers
		* This is described in paper. I won't spoil it here, but it could involve some bin searching :P
* The solution to (1) is interesting, because it uses techniques in (2). 
	* In order to avoid unwanted connection killing, the authors would not send spoofed RST packets but instead sent spoofed DATA packets.
	* This requires a decent grasp on the current ACK number, but allows for sequence number guessing without the risk of killing a connection.

#### 6. Other Practical Considerations
* Detecting and Handling Packet Loss
    	* Sometimes, packets get lost or corrupted in-transit. This could lead to dropped probes or dropped challenge ACKs (and subsequently false positives/negatives)
	* Potential solution: Re-probe if skeptical!
	* Potential solution: Use smart bin numbers that should always result in an odd number of challenge ACKs (if a packet is lost, the challenge ACK count maybe even)
* Moving ACK and sequence numbers
	* No solutions were proposed. Left as an idea for future work.
* Per-Connection Rate Limits
	* Apparently, the Linux kernel (since 4.0) has a per-connection rate-limit (TIL!).
	* This rate-limit only applies to SYN packets.
* Configurable maximum challenge ACK count
	* This is easy to determine with a valid connection 

#### 7. Evaluations
* Results here are hard to translate to markdown but are worthwhile and decently successful.

#### 8. Discussion and Defenses
* Potential Solution 1: Make the challenge ACK maximum per-connection.
	* This eliminates the side channel but, could potentially grow to be quite large as the number of connections increase.
* Potential Solution 2: Add noise to the global challenge ack maximum (increase it / decrease it randomly on each interval change)

### Takeaways, Notes, Conclusions, Unanswered Questions
* Does clock drift affect samples at all? I am skeptical that, once they synchronize their clock with the target, that clock stays in sync.
* Interesting Takeaway: Selective connection resets could allow an attacker to intelligently route Tor traffic through certain relays (end of section 7.1.2)
